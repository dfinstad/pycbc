#!/usr/bin/env python

# Copyright (C) 2016 Christopher M. Biwer, Collin Capano
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
""" Runs a sampler to find the posterior distributions.
"""

import os
import argparse
import logging
import shutil
import h5py
import time

import numpy
import healpy

import pycbc
from pycbc import (distributions, transforms, fft,
                   opt, scheme)
from pycbc.waveform import generator

from pycbc import __version__
from pycbc import inference
from pycbc.inference import (models, burn_in, option_utils)
from pycbc.detector import Detector
from pycbc.workflow import configuration

# command line usage
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)
parser.add_argument("--version", action="version", version=__version__,
                    help="Prints version information.")
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Print logging messages.")
# output options
parser.add_argument("--output-file", type=str, required=True,
                    help="Output file path.")
parser.add_argument("--force", action="store_true", default=False,
                    help="If the output-file already exists, overwrite it. "
                         "Otherwise, an OSError is raised.")
parser.add_argument("--save-backup", action="store_true",
                    default=False,
                    help="Don't delete the backup file after the run has "
                         "completed.")
# parallelization options
parser.add_argument("--nprocesses", type=int, default=1,
                    help="Number of processes to use. If not given then only "
                         "a single core will be used.")
parser.add_argument("--use-mpi", action='store_true', default=False,
                    help="Use MPI to parallelize the sampler")
parser.add_argument("--samples-file", default=None,
                    help="Use an iteration from an InferenceFile as the "
                         "initial proposal distribution. The same "
                         "number of walkers and the same [variable_params] "
                         "section in the configuration file should be used. "
                         "The priors must allow encompass the initial "
                         "positions from the InferenceFile being read.")
parser.add_argument("--seed", type=int, default=0,
                    help="Seed to use for the random number generator that "
                         "initially distributes the walkers. Default is 0.")
# relative binning workflow options
parser.add_argument("--relbin-workflow", action="store_true",
                    help="Switch to indicate relative binning workflow "
                         "analysis. Will read search pipeline output and "
                         "set config options and prior bounds accordingly.")
parser.add_argument("--skymap-file", type=str,
                    help="Bayestar sky localization FITS file from a search "
                         "pipeline injection.")
parser.add_argument("--template-bank-file", type=str,
                    help="Template bank hdf file that was used in search "
                         "pipeline.")
parser.add_argument("--injfind-file", type=str,
                    help="HDFINJFIND file from search pipeline.")
# add config options
configuration.add_workflow_command_line_group(parser)
# add module pre-defined options
fft.insert_fft_option_group(parser)
opt.insert_optimization_option_group(parser)
scheme.insert_processing_option_group(parser)

# parse command line
opts = parser.parse_args()

# setup log
# If we're running in MPI mode, only allow the parent to print
if opts.use_mpi:
    from mpi4py import MPI
    rank = MPI.COMM_WORLD.Get_rank()
    opts.verbose &= rank == 0
pycbc.init_logging(opts.verbose)

# verify options are sane
fft.verify_fft_options(opts, parser)
opt.verify_optimization_options(opts, parser)
scheme.verify_processing_options(opts, parser)

# set seed
numpy.random.seed(opts.seed)
logging.info("Using seed %i", opts.seed)

# we'll silence numpy warnings since they are benign and make for confusing
# logging output
numpy.seterr(divide='ignore', invalid='ignore')

# get scheme
ctx = scheme.from_cli(opts)
fft.from_cli(opts)

with ctx:

    # read configuration file
    cp = configuration.WorkflowConfigParser.from_cli(opts)

    # setup relbin workflow if necessary
    if opts.relbin_workflow:
        logging.info("Running relative binning workflow analysis")
        # try to avoid race condition in config file
        for i in range(3):
            try:
                inj_file = os.path.basename(cp.get('data', 'injection-file'))
            except:
                logging.info("Failed to read config file on try {}".format(i+1))
                time.sleep(0.1)
                continue
        inj_idx = int(inj_file.split('_')[1][:-4])
        ifos = cp.get('data', 'instruments').split()
        # get template id and inj params for diagnostic
        logging.info("Reading injfind file")
        with h5py.File(opts.injfind_file, 'r') as fp:
            found = list(fp['found_after_vetoes/injection_index'][:])
            found_idx = found.index(inj_idx)
            times = {ifo: fp['found_after_vetoes/{}/time'.format(ifo)][found_idx]
                     for ifo in ifos}
            t_idx = fp['found_after_vetoes/template_id'][found_idx]
            inj_params = {k: v[inj_idx] for k, v in fp['injections'].items()}
        logging.info("Injection parameters:")
        for k, v in inj_params.items():
            logging.info("{} = {}".format(k, v))
        # get template params
        logging.info("Reading template bank file")
        with h5py.File(opts.template_bank_file, 'r') as fp:
            bank_params = fp.attrs['parameters']
            ref_params = {p: fp[p][t_idx] for p in bank_params if
                          p not in ['f_lower', 'template_hash']}
        # read skymap
        logging.info("Reading skymap file")
        hpx = healpy.read_map(opts.skymap_file, verbose=False)
        nside = healpy.npix2nside(len(hpx))
        total_prob = numpy.sum(hpx)
        sort_idx = numpy.argsort(hpx)
        # find all pixels in 95% confidence region
        skyloc95_pix = sort_idx[numpy.cumsum(numpy.array(hpx)[sort_idx]) >=
                                0.05 * total_prob]
        # convert to ra and dec
        skyloc95_ang = healpy.pix2ang(nside, skyloc95_pix)
        dec = 0.5 * numpy.pi - skyloc95_ang[0]
        ra = skyloc95_ang[1]
        mean_ra = 0.5 * (min(ra) + max(ra))
        mean_dec = 0.5 * (min(dec) + max(dec))
        ref_params.update({'ra': mean_ra, 'dec': mean_dec})
        # get skyloc bounds with minimum fallback if necessary
        ra_min = min(ra) if max(ra) - min(ra) >= 0.5 else mean_ra - 0.25
        ra_max = max(ra) if max(ra) - min(ra) >= 0.5 else mean_ra + 0.25
        dec_min = min(dec) if max(dec) - min(dec) >= 0.25 else mean_dec - 0.125
        dec_max = max(dec) if max(dec) - min(dec) >= 0.25 else mean_dec + 0.125
        # set ref tc as average of trigger times
        tcs = [times[ifo] - Detector(ifo).time_delay_from_earth_center(
                   mean_ra, mean_dec, times[ifo]) for ifo in times if
               times[ifo] != -1.0]
        ref_params['tc'] = numpy.mean(tcs)
        tc_min = ref_params['tc'] - 0.2
        tc_max = ref_params['tc'] + 0.2
        # set fiducial waveform params in config
        logging.info("Setting fiducial parameters and prior bounds")
        logging.info("Fiducial parameters:")
        for k, v in ref_params.items():
            logging.info("{} = {}".format(k, v))
            cp.set('model', str(k) + '_ref', str(v))
        # set skyloc and tc prior bounds in config
        logging.info("Setting RA bounds to {}, {}".format(ra_min, ra_max))
        cp.set('prior-ra', 'name', 'uniform_angle')
        cp.set('prior-ra', 'min-ra', str(ra_min / numpy.pi))
        cp.set('prior-ra', 'max-ra', str(ra_max / numpy.pi))
        logging.info("Setting dec bounds to {}, {}".format(dec_min, dec_max))
        cp.set('prior-dec', 'name', 'cos_angle')
        cp.set('prior-dec', 'min-dec', str(dec_min / numpy.pi))
        cp.set('prior-dec', 'max-dec', str(dec_max / numpy.pi))
        logging.info("Setting tc bounds to {}, {}".format(tc_min, tc_max))
        cp.set('prior-tc', 'min-tc', str(tc_min))
        cp.set('prior-tc', 'max-tc', str(tc_max))

    # create an empty checkpoint file, if needed
    condor_ckpt = cp.has_option('sampler', 'checkpoint-signal')
    if condor_ckpt:
        logging.info(
            "Sampler will exit with signal {} after checkpointing".format(
                cp.get('sampler', 'checkpoint-signal')))
        # create an empty output file to keep condor happy
        open(opts.output_file, 'a').close()

    logging.info("Setting up model")

    # construct class that will return the natural logarithm of likelihood
    model = models.read_from_config(cp)

    logging.info("Setting up sampler")

    # Create sampler that will run.
    # Note: the pool is created at this point. This means that,
    # unless you enjoy angering your cluster admins,
    # NO SAMPLES FILE IO SHOULD BE DONE PRIOR TO THIS POINT!!!
    sampler = inference.sampler.load_from_config(
        cp, model, nprocesses=opts.nprocesses, use_mpi=opts.use_mpi)

    # set up output/checkpoint file
    sampler.setup_output(opts.output_file, force=opts.force)

    # Figure out where to get the initial conditions from: a samples file,
    # the checkpoint file, the prior, or an initial prior.
    samples_file = opts.samples_file
    # use the checkpoint file instead if resume from checkpoint
    if not sampler.new_checkpoint:
        samples_file = sampler.checkpoint_file
    if samples_file is not None:
        logging.info("Initial positions taken from last iteration in %s",
                     samples_file)
        init_prior = None
    else:
        # try to load an initial distribution from the config file
        init_prior = inference.sampler.initial_dist_from_config(
            cp, sampler.variable_params)

    sampler.set_initial_conditions(initial_distribution=init_prior,
                                   samples_file=samples_file)

    # Run the sampler
    sampler.run()

    # Finalize the output
    sampler.finalize()

if condor_ckpt:
   # unlink the empty output file
   try:
       os.unlink(opts.output_file)
   except:
       pass

# rename checkpoint to output and delete backup
logging.info("Moving checkpoint to output")
os.rename(sampler.checkpoint_file, opts.output_file)
if not opts.save_backup:
    logging.info("Deleting backup file")
    os.remove(sampler.backup_file)

if condor_ckpt:
   # create an empty checkpoint file
   open(sampler.checkpoint_file, 'a').close()

# exit
logging.info("Done")
