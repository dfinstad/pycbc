#!/home/daniel.finstad/opt/pycbc-dev/bin/python

# Copyright (C) 2016 Christopher M. Biwer, Collin Capano
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
""" Runs a sampler to find the posterior distributions.
"""

import os
import argparse
import logging
import shutil
import h5py
import time

import numpy
import healpy

import pycbc
from pycbc import (distributions, transforms, fft,
                   opt, scheme)
from pycbc.waveform import generator

from pycbc import __version__
from pycbc import inference
from pycbc.inference import (models, burn_in, option_utils)
from pycbc.detector import Detector
from pycbc.conversions import (mchirp_from_mass1_mass2,
                               eta_from_mass1_mass2,
                               mass1_from_mchirp_eta,
                               mass2_from_mchirp_eta)
from pycbc.workflow import configuration

# command line usage
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)
parser.add_argument("--version", action="version", version=__version__,
                    help="Prints version information.")
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Print logging messages.")
# output options
parser.add_argument("--output-file", type=str, required=True,
                    help="Output file path.")
parser.add_argument("--force", action="store_true", default=False,
                    help="If the output-file already exists, overwrite it. "
                         "Otherwise, an OSError is raised.")
parser.add_argument("--save-backup", action="store_true",
                    default=False,
                    help="Don't delete the backup file after the run has "
                         "completed.")
# parallelization options
parser.add_argument("--nprocesses", type=int, default=1,
                    help="Number of processes to use. If not given then only "
                         "a single core will be used.")
parser.add_argument("--use-mpi", action='store_true', default=False,
                    help="Use MPI to parallelize the sampler")
parser.add_argument("--samples-file", default=None,
                    help="Use an iteration from an InferenceFile as the "
                         "initial proposal distribution. The same "
                         "number of walkers and the same [variable_params] "
                         "section in the configuration file should be used. "
                         "The priors must allow encompass the initial "
                         "positions from the InferenceFile being read.")
parser.add_argument("--seed", type=int, default=0,
                    help="Seed to use for the random number generator that "
                         "initially distributes the walkers. Default is 0.")
# relative binning workflow options
parser.add_argument("--relbin-workflow", action="store_true", default=False,
                    help="Switch to indicate relative binning workflow "
                         "analysis. Will read search pipeline output and "
                         "set config options and prior bounds accordingly.")
parser.add_argument("--skymap-file", type=str,
                    help="Bayestar sky localization FITS file from a search "
                         "pipeline injection.")
parser.add_argument("--template-bank-file", type=str,
                    help="Template bank hdf file that was used in search "
                         "pipeline.")
parser.add_argument("--injfind-file", type=str,
                    help="HDFINJFIND file from search pipeline.")
parser.add_argument("--timed", action="store_true",
                    help="Record runtime in auxiliary txt file.")
parser.add_argument("--use-inj-parameters", action="store_true", default=False,
                    help="Run in diagnostic mode using injection values "
                         "as fidcuial waveform parameters.")
# add config options
configuration.add_workflow_command_line_group(parser)
# add module pre-defined options
fft.insert_fft_option_group(parser)
opt.insert_optimization_option_group(parser)
scheme.insert_processing_option_group(parser)

# parse command line
opts = parser.parse_args()

# set run start time in case we want to store it
start_time = time.time()

# setup log
# If we're running in MPI mode, only allow the parent to print
if opts.use_mpi:
    from mpi4py import MPI
    rank = MPI.COMM_WORLD.Get_rank()
    opts.verbose &= rank == 0
pycbc.init_logging(opts.verbose)

# verify options are sane
fft.verify_fft_options(opts, parser)
opt.verify_optimization_options(opts, parser)
scheme.verify_processing_options(opts, parser)

# set seed
numpy.random.seed(opts.seed)
logging.info("Using seed %i", opts.seed)

# we'll silence numpy warnings since they are benign and make for confusing
# logging output
numpy.seterr(divide='ignore', invalid='ignore')

# get scheme
ctx = scheme.from_cli(opts)
fft.from_cli(opts)

with ctx:

    # read configuration file
    if not opts.use_mpi:
        cp = configuration.WorkflowConfigParser.from_cli(opts)
    else:
        if rank == 0:
            cp = configuration.WorkflowConfigParser.from_cli(opts)
        else:
            cp = None
        cp = MPI.COMM_WORLD.bcast(cp, root=0)

    # setup relbin workflow if necessary
    if opts.relbin_workflow:
        logging.info("Running relative binning workflow analysis")
        inj_path = cp.get('data', 'injection-file')
        inj_file = os.path.basename(inj_path)
        inj_idx = int(inj_file.split('_')[1][:-4])

        ifos = cp.get('data', 'instruments').split()
        ref_params = {}
        times = {}
        # get template id and inj params for diagnostic
        logging.info("Reading injfind file")
        with h5py.File(opts.injfind_file, 'r') as fp:
            found = list(fp['found_after_vetoes/injection_index'][:])
            found_idx = found.index(inj_idx)
            times = {ifo: fp['found_after_vetoes/{}/time'.format(ifo)][found_idx]
                     for ifo in ifos}
            t_idx = fp['found_after_vetoes/template_id'][found_idx]
            inj_params = {k: v[inj_idx] for k, v in fp['injections'].items()}
        inj_params['mchirp'] = mchirp_from_mass1_mass2(inj_params['mass1'],
                                                       inj_params['mass2'])
        inj_params['eta'] = eta_from_mass1_mass2(inj_params['mass1'],
                                                 inj_params['mass2'])
        # report injection parameters
        logging.info("Injection parameters:")
        for k, v in inj_params.items():
            logging.info("{} = {:.5f}".format(k, v))
        # get template params
        logging.info("Reading template bank file")
        with h5py.File(opts.template_bank_file, 'r') as fp:
            bank_params = fp.attrs['parameters']
            ref_params = {p: fp[p][t_idx] for p in bank_params if
                          p not in ['f_lower', 'template_hash']}
        # read skymap
        if opts.skymap_file:
            logging.info("Reading skymap file")
            hpx = healpy.read_map(opts.skymap_file, verbose=False)
            nside = healpy.npix2nside(len(hpx))
            total_prob = numpy.sum(hpx)
            sort_idx = numpy.argsort(hpx)
            # find all pixels in 95% confidence region
            skyloc95_pix = sort_idx[numpy.cumsum(numpy.array(hpx)[sort_idx]) >=
                                    0.05 * total_prob]
            # convert to ra and dec
            skyloc95_ang = healpy.pix2ang(nside, skyloc95_pix)
            dec = 0.5 * numpy.pi - skyloc95_ang[0]
            ra = skyloc95_ang[1]
            mean_ra = 0.5 * (min(ra) + max(ra))
            mean_dec = 0.5 * (min(dec) + max(dec))
            # get skyloc bounds with minimum fallback if necessary
            ra_min = min(ra) if max(ra) - min(ra) >= 0.5 else mean_ra - 0.25
            ra_max = max(ra) if max(ra) - min(ra) >= 0.5 else mean_ra + 0.25
            dec_min = min(dec) if max(dec) - min(dec) >= 0.25 else mean_dec - 0.125
            dec_max = max(dec) if max(dec) - min(dec) >= 0.25 else mean_dec + 0.125
        else:
            if cp.has_option('relbin_workflow', 'skyloc_debug'):
                logging.warn("WARNING! Running in skyloc debug mode, using "
                             "injection parameters for fiducial waveform")
                mean_ra = inj_params['longitude']
                mean_dec = inj_params['latitude']
            else:
                mean_ra = numpy.pi
                mean_dec = 0.0

        ref_params.update({'ra': mean_ra, 'dec': mean_dec})
        # set ref tc as average of trigger times
        tcs = [times[ifo] for ifo in times if times[ifo] != -1.0]
        ref_params['tc'] = numpy.mean(tcs)
        # check for diagnostic mode
        if opts.use_inj_parameters:
            logging.warn("WARNING! Running in diagnostic mode, using "
                         "injection parameters for fiducial waveform")
            pmap = {'dec': 'latitude', 'ra': 'longitude', 'tc': 'end_time'}
            fidparams = ['mass1', 'mass2', 'spin1z', 'spin2z', 'ra', 'dec',
                         'tc']
            ref_params = {p: inj_params[p] if p in inj_params else
                          inj_params[pmap[p]] for p in fidparams}
        # add derived params (mchirp and eta)
        ref_params['mchirp'] = mchirp_from_mass1_mass2(
           ref_params['mass1'], ref_params['mass2'])
        ref_params['eta'] = eta_from_mass1_mass2(
           ref_params['mass1'], ref_params['mass2'])
        tc_min = ref_params['tc'] - 0.2
        tc_max = ref_params['tc'] + 0.2
        # set fiducial waveform params in config
        logging.info("Setting fiducial parameters and prior bounds")
        logging.info("Fiducial parameters:")
        for k, v in ref_params.items():
            logging.info("{} = {:.5f}".format(k, v))
            # don't pass in mchirp or eta
            if k not in ['mchirp', 'eta']:
                cp.set('model', str(k) + '_ref', str(v))
        # set variable param prior bounds around best fit template
        delta_mc = 1.5e-2
        delta_eta = 2.5e-2
        mc_min = ref_params['mchirp'] - delta_mc
        mc_max = ref_params['mchirp'] + delta_mc
        eta_min = ref_params['eta'] - delta_eta
        eta_max = 0.25

        if cp.has_option('relbin_workflow', 'mchirp_cut'):
            logging.info("Setting mchirp constraint to {}, {}".format(mc_min, mc_max))
            cp.set('constraint-1', 'constraint_arg',
                   'mchirp_from_mass1_mass2(mass1,mass2) > {}'.format(mc_min))
            cp.set('constraint-2', 'constraint_arg',
                   'mchirp_from_mass1_mass2(mass1,mass2) < {}'.format(mc_max))
        if cp.has_option('relbin_workflow', 'eta_cut'):
            logging.info("Setting eta constraint to {}".format(eta_min))
            cp.set('constraint-3', 'constraint_arg',
                   'eta_from_mass1_mass2(mass1,mass2) > {}'.format(eta_min))

        # if priors are in mchirp, eta
        if cp.has_option('relbin_workflow', 'mchirp_eta_prior'):
            logging.info("Setting mchirp bounds to {}, {}".format(mc_min, mc_max))
            cp.set('prior-mchirp', 'min-mchirp', str(mc_min))
            cp.set('prior-mchirp', 'max-mchirp', str(mc_max))
            logging.info("Setting eta bounds to {}, {}".format(eta_min, eta_max))
            cp.set('prior-eta', 'min-eta', str(eta_min))
            cp.set('prior-eta', 'max-eta', str(eta_max))

        # if priors are in m1, m2
        if cp.has_option('relbin_workflow', 'm1m2_prior'):
            m1_min = max(1., mass1_from_mchirp_eta(mc_min, eta_max))
            m1_max = min(5., mass1_from_mchirp_eta(mc_max, eta_min))
            m2_min = max(1., mass2_from_mchirp_eta(mc_min, eta_min))
            m2_max = min(5., mass2_from_mchirp_eta(mc_max, eta_max))
            logging.info("Setting mass1 bounds to {}, {}".format(m1_min, m1_max))
            cp.set('prior-mass1', 'min-mass1', str(m1_min))
            cp.set('prior-mass1', 'max-mass1', str(m1_max))
            logging.info("Setting mass2 bounds to {}, {}".format(m2_min, m2_max))
            cp.set('prior-mass2', 'min-mass2', str(m2_min))
            cp.set('prior-mass2', 'max-mass2', str(m2_max))

        cp.set('prior-ra', 'name', 'uniform_angle')
        cp.set('prior-dec', 'name', 'cos_angle')
        if opts.skymap_file:
            # set skyloc and tc prior bounds in config
            logging.info("Setting RA bounds to {}, {}".format(ra_min, ra_max))
            cp.set('prior-ra', 'min-ra', str(ra_min / numpy.pi))
            cp.set('prior-ra', 'max-ra', str(ra_max / numpy.pi))
            logging.info("Setting dec bounds to {}, {}".format(dec_min, dec_max))
            cp.set('prior-dec', 'min-dec', str(dec_min / numpy.pi))
            cp.set('prior-dec', 'max-dec', str(dec_max / numpy.pi))
        logging.info("Setting tc bounds to {}, {}".format(tc_min, tc_max))
        cp.set('prior-tc', 'min-tc', str(tc_min))
        cp.set('prior-tc', 'max-tc', str(tc_max))

    # set up non-workflow relbin inj run
    if opts.use_inj_parameters and not opts.relbin_workflow:
        # read injection file
        logging.info("Reading injection file")
        inj_file = cp.get('data', 'injection-file')
        with h5py.File(inj_file, 'r') as fp:
            inj_params = {k: v for k, v in fp.attrs.items()}
            inj_params.update({k: v[0] for k, v in fp.items()})
        # report injection parameters
        logging.info("Injection parameters:")
        for k, v in inj_params.items():
            if not isinstance(v, float):
                continue
            logging.info("{} = {:.5f}".format(k, v))
        # set config model params
        logging.info("Setting fiducial waveform params in config")
        model_params = ['mass1', 'mass2', 'spin1z', 'spin2z', 'lambda1',
                        'lambda2', 'tc', 'ra', 'dec', 'inclination',
                        'polarization']
        for p in model_params:
            cp.set('model', '{}_ref'.format(p), str(inj_params[p]))

    # create an empty checkpoint file, if needed
    condor_ckpt = cp.has_option('sampler', 'checkpoint-signal')
    if condor_ckpt:
        logging.info(
            "Sampler will exit with signal {} after checkpointing".format(
                cp.get('sampler', 'checkpoint-signal')))
        # create an empty output file to keep condor happy
        open(opts.output_file, 'a').close()

    logging.info("Setting up model")

    # construct class that will return the natural logarithm of likelihood
    model = models.read_from_config(cp)

    logging.info("Setting up sampler")

    # Create sampler that will run.
    # Note: the pool is created at this point. This means that,
    # unless you enjoy angering your cluster admins,
    # NO SAMPLES FILE IO SHOULD BE DONE PRIOR TO THIS POINT!!!
    sampler = inference.sampler.load_from_config(
        cp, model, nprocesses=opts.nprocesses, use_mpi=opts.use_mpi)

    # set up output/checkpoint file
    sampler.setup_output(opts.output_file, force=opts.force)

    # Figure out where to get the initial conditions from: a samples file,
    # the checkpoint file, the prior, or an initial prior.
    samples_file = opts.samples_file
    # use the checkpoint file instead if resume from checkpoint
    if not sampler.new_checkpoint:
        samples_file = sampler.checkpoint_file
    if samples_file is not None:
        logging.info("Initial positions taken from last iteration in %s",
                     samples_file)
        init_prior = None
    else:
        # try to load an initial distribution from the config file
        init_prior = inference.sampler.initial_dist_from_config(
            cp, sampler.variable_params)

    sampler.set_initial_conditions(initial_distribution=init_prior,
                                   samples_file=samples_file)

    # Run the sampler
    sampler.run()

    # Finalize the output
    sampler.finalize()

if condor_ckpt:
   # unlink the empty output file
   try:
       os.unlink(opts.output_file)
   except:
       pass

# rename checkpoint to output and delete backup
logging.info("Moving checkpoint to output")
os.rename(sampler.checkpoint_file, opts.output_file)
if not opts.save_backup:
    logging.info("Deleting backup file")
    os.remove(sampler.backup_file)

if condor_ckpt:
   # create an empty checkpoint file
   open(sampler.checkpoint_file, 'a').close()

# calculate run time and write to file if option given
runtime = time.time() - start_time
if opts.timed:
    logging.info("Writing runtime file")
    rtime_file = opts.output_file[:-4] + '_runtime.txt'
    with open(rtime_file, 'w') as fp:
        fp.write('{}\n'.format(runtime))

# exit
logging.info("Done")
