#!/usr/bin/env python

import os, logging, h5py, copy
import numpy
import pycbc.workflow as wf
import pycbc.workflow.pegasus_workflow as wdax
from pycbc.detector import Detector
from pycbc.workflow import minifollowups as mini
from pycbc.types import MultiDetOptionAction
from pycbc.io.hdf import SingleDetTriggers
from argparse import ArgumentParser

def to_file(path, ifo=None):
    fil = wdax.File(os.path.basename(path))
    fil.ifo = ifo
    path = os.path.abspath(path)
    fil.PFN(path, 'local')
    return fil

parser = ArgumentParser()
parser.add_argument('--workflow-name', default='my_unamed_run')
parser.add_argument("-d", "--output-dir", default=None,
                    help="Path to output directory.")
parser.add_argument('--bank-file',
                    help="HDF format template bank file")
parser.add_argument('--injection-file',
                    help="HDF format injection results file")
parser.add_argument('--injection-xml-file',
                    help="XML format injection file")
parser.add_argument('--single-detector-triggers', nargs='+', action=MultiDetOptionAction,
                    help="HDF format merged single detector trigger files")
parser.add_argument('--inspiral-segments',
                    help="xml segment files containing the inspiral analysis times")
parser.add_argument('--inspiral-data-read-name',
                    help="Name of inspiral segmentlist containing data read in "
                         "by each analysis job.")
parser.add_argument('--inspiral-data-analyzed-name',
                    help="Name of inspiral segmentlist containing data "
                         "analyzed by each analysis job.")
parser.add_argument('--inj-window', type=int, default=0.5,
                    help="Time window in which to look for injection triggers")
parser.add_argument('--ifar-threshold', type=float, default=None,
                    help="If given also followup injections with ifar smaller "
                         "than this threshold.")
parser.add_argument('--output-map')
parser.add_argument('--output-file')
parser.add_argument('--transformation-catalog')
parser.add_argument('--tags', nargs='+', default=[])
wf.add_workflow_command_line_group(parser)
args = parser.parse_args()

logging.basicConfig(format='%(asctime)s:%(levelname)s : %(message)s',
                    level=logging.INFO)

workflow = wf.Workflow(args, args.workflow_name)

wf.makedir(args.output_dir)


# convert inspiral segments to file
insp_segs = to_file(args.inspiral_segments)
injection_xml_file = to_file(args.injection_xml_file)

# build single triggers list
single_triggers = []
for ifo in args.single_detector_triggers:
    fname = args.single_detector_triggers[ifo]
    single_triggers.append(to_file(fname, ifo=ifo))

# grab found injection indices
f = h5py.File(args.injection_file, 'r')
found = f['found_after_vetoes/injection_index'][:]

tc_dict = {ifo: f['found_after_vetoes/{}/time'.format(ifo)][:] for ifo in
           workflow.ifos}

# loop over found injections to follow up
for i, idx in enumerate(found):
    files = wf.FileList([])
    time = f['injections/end_time'][idx]
    ifo_times = ''
    inj_params = {}
    skip_ifos = []
    for val in ['mass1', 'mass2', 'spin1z', 'spin2z', 'end_time']:
        inj_params[val] = f['injections/%s' %(val,)][idx]
    for single in single_triggers:
        ifo = single.ifo
        ifo_time = tc_dict[ifo][i]
        # skip ifos that did not participate in coinc
        logging.info("IFO: {}, tc: {}".format(ifo, ifo_time))
        if ifo_time == -1.0:
            logging.info("Adding {} to skip_ifos")
            skip_ifos.append(ifo)
            continue
        det = Detector(ifo)
        lon = f['injections/longitude'][idx]
        lat = f['injections/latitude'][idx]
        ifo_times += ' %s:%s ' % (ifo, ifo_time)
        inj_params[ifo+'_end_time'] = ifo_time

    for curr_ifo in args.single_detector_triggers:
        logging.info("Current IFO is {}".format(curr_ifo))
        if curr_ifo in skip_ifos:
            logging.info("Current IFO is in skip_ifos, skipping")
            continue
        single_fname = args.single_detector_triggers[curr_ifo]
        hd_sngl = SingleDetTriggers(single_fname, args.bank_file, None, None,
                                    None, curr_ifo)

        end_times = hd_sngl.end_time
        # Use SNR here or NewSNR??
        snr = hd_sngl.snr
        lgc_mask = abs(end_times - inj_params['end_time']) < args.inj_window

        if len(snr[lgc_mask]) == 0:
            continue

        snr_idx = numpy.arange(len(lgc_mask))[lgc_mask][snr[lgc_mask].argmax()]
        hd_sngl.mask = [snr_idx]
        curr_params = copy.deepcopy(inj_params)
        curr_params['mass1'] = hd_sngl.mass1[0]
        curr_params['mass2'] = hd_sngl.mass2[0]
        curr_params['spin1z'] = hd_sngl.spin1z[0]
        curr_params['spin2z'] = hd_sngl.spin2z[0]
        curr_params['f_lower'] = hd_sngl.f_lower[0]
        # don't require precessing template info if not present
        try:
            curr_params['spin1x'] = hd_sngl.spin1x[0]
            curr_params['spin2x'] = hd_sngl.spin2x[0]
            curr_params['spin1y'] = hd_sngl.spin1y[0]
            curr_params['spin2y'] = hd_sngl.spin2y[0]
            curr_params['inclination'] = hd_sngl.inclination[0]
        except KeyError:
            pass
        try:
            # Only present for precessing search
            curr_params['u_vals'] = hd_sngl.u_vals[0]
        except:
            pass

        curr_tags = ['SNR_SERIES_%s' %(curr_ifo,)]
        curr_tags += [str(idx)]
        files += mini.make_single_template_plots(workflow, insp_segs,
                                args.inspiral_data_read_name,
                                args.inspiral_data_analyzed_name, curr_params,
                                args.output_dir, inj_file=injection_xml_file,
                                tags=args.tags + curr_tags,
                                params_str='loudest template in %s' % curr_ifo,
                                window=0.09960937 )

workflow.save(filename=args.output_file, output_map_path=args.output_map,
              transformation_catalog_path=args.transformation_catalog)

